PYTHON DATASTRUCTURES BASICS:

STRINGS:
data = 'hello'
data[0] #Output: h #return first element #index starts with 0
data[1:4] #Output: ell #return element starting from index 1 and ending with index 3 (n-1=4-1 in this case)
data[-1] #Output: o #return last element
data[:-1] #Output: hell #return all elements except last element
data[::-1] #Output: olleh #reverse


INT:


LIST:
data = ['a', 'b', 'c']
data = [[0, 1], ['a', 'b'], [4, 5]] #also be called as matrix

#Create a list of hundres zeros
data = [0] * 100 
#Output: [0, 0, 0, 0,..........0] #a list of 100 zeroes

#combining lists
data = ['a', 'b']
zeroes = [0] * 5
print(data + zeroes)
#Output: ['a', 'b', 0, 0, 0, 0, 0]

TUPLE:


DICTIONARY:



SET:
Sets in Python are unordered collections of unique elements
Declared as :
order = set()
NOTE: Defining sets as order = {} will treat order as dictionary not set
Example:
set1 = {1, 2, 3}
set2 = {3, 4, 5}


# Union
print(set1 | set2)  # Output: {1, 2, 3, 4, 5}

# Intersection
print(set1 & set2)  # Output: {3}

# Difference
print(set1 - set2)  # Output: {1, 2}

# Symmetric Difference
print(set1 ^ set2)  # Output: {1, 2, 4, 5} #All elements of both sets except the common elements for both sets

#Adding elements
set1.add(7)
print(set1) #Output: {1, 2, 3, 7}

Operators	Notes
key in s	            containment check
key not in s	        non-containment check
s1 == s2	            s1 is equivalent to s2
s1 != s2	            s1 is not equivalent to s2
s1 <= s2	            s1 is subset of s2
s1 < s2	              s1 is proper subset of s2
s1 >= s2	            s1 is superset of s2
s1 > s2	              s1 is proper superset of s2
s1 | s2	              the union of s1 and s2
s1 & s2	              the intersection of s1 and s2
s1 – s2	              the set of elements in s1 but not s2
s1 ˆ s2	              the set of elements in precisely one of s1 or s2

# typecasting list to set
myset = set(["a", "b", "c"])
print(myset)

# Adding element to the set
myset.add("d")
print(myset)

Output:
Python set is an unordered datatype, which means we cannot know in which order the elements of the set are stored.
{'c', 'b', 'a'}
{'d', 'c', 'b', 'a'}
